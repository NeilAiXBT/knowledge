ðŸ”¸ðŸ”¸ðŸ”¸ðŸ”¸ðŸ”¸句子列表 (1867 个句子)ðŸ”¸ðŸ”¸ðŸ”¸ðŸ”¸ðŸ”¸
Effective Go - Go 编程语言
文档 有效 Go 有效 Go 简介 Go 是一种新语言。
虽然它借鉴了现有语言的思想，
但它具有不同寻常的属性，使得有效的 Go 程序在特性上与其相关语言编写的程序不同。
将 C++ 或 Java 程序直接翻译成 Go 语言不太可能产生令人满意的结果——Java 程序是用 Java 编写的，
而不是 Go。
另一方面，
从 Go 的角度思考问题可能会产生一个成功但完全不同的程序。
换句话说，
为了写好 Go 语言，
理解它的特性和惯用法很重要。
了解 Go 编程的既定约定也很重要，
比如命名，
格式化，
程序构建，
等等，
这样你编写的程序就容易被其他 Go 程序员理解。
本文档提供了编写清晰、
地道的 Go 代码。
它补充了语言规范，
Go 语言之旅，
以及如何编写 Go 代码，
所有这些您应该首先阅读。
1 月份添加的注释，
2022 年：本文档是为 2009 年 Go 发布而编写的，
并且自那以后没有进行过重大更新。
虽然它是理解如何使用该语言本身的好指南，
感谢语言的稳定性，
它很少提及库，也没有提及自编写以来 Go 生态系统的重大变化，
例如构建系统，
测试，
模块，
和多态性。
目前没有更新它的计划，
因为已经发生了很多事情，并且有大量且不断增长的文档，
博客，
和书籍在描述现代 Go 用法方面做得很好。
Effective Go 仍然很有用，
但读者应该明白，这远非一份完整的指南。
请参阅问题 28782 以了解上下文。
示例 Go 包源旨在不仅用作核心库，还用作如何使用该语言的示例。
此外，
许多软件包包含可工作的、
独立的、可执行的示例，您可以直接从 go.dev 网站运行它们，
例如这样的一个（如果需要的话）
单击“示例”一词将其打开）。
如果您对如何处理问题或如何实施某些内容有疑问，
该文档，
库中的代码和示例可以提供答案，
想法和背景。
格式化 格式化问题是最有争议但最不重要的。
人们可以适应不同的格式风格，但如果他们不必这样做会更好，
如果每个人都坚持相同的风格，那么花在主题上的时间就会减少。
问题是如何在没有冗长规定性风格指南的情况下接近这个乌托邦。
通过 Go，我们采用了一种不寻常的方法，让机器来处理大部分格式问题。
gofmt 程序（也可以使用 go fmt 命令，
它在包级别而不是源文件级别运行）读取 Go 程序并以标准的缩进和垂直对齐方式发出源代码，
保留并在必要时重新格式化注释。
如果你想知道如何处理一些新的布局情况，
运行 gofmt；
如果答案看起来不太对劲，
重新安排你的程序（或者提交一个关于 gofmt 的 bug），
不要试图解决它。
例如，
没有必要花时间对齐结构体字段上的注释。
Gofmt 会为你做这件事。
假设有如下声明：type T struct { name string // object 的名字 value int // 它的值 } gofmt 会对齐这些列：type T struct { name string // object 的名字 value int // 它的值 } 所有标准包中的 Go 代码都已使用 gofmt 格式化。
还有一些格式细节需要处理。
简而言之：缩进。我们使用制表符进行缩进，并且 gofmt 默认会输出制表符。
仅在必要时使用空格。
Go 语言对行长度没有限制。
不要担心穿孔卡片溢出。
如果一行感觉太长，
将其换行并用额外的制表符缩进。
Go 语言的括号比 C 和 Java 少：控制结构（if，
for，
switch) 语法中不包含括号。
也，
运算符优先级层次结构更短更清晰，
因此 x<<8 + y<<16 的含义与空格所暗示的含义相同，
这与其他语言不同。
注释 Go 提供了 C 风格的 /* */ 块注释和 C++ 风格的 // 行注释。
行注释是常态；
块注释主要作为包注释出现，
但在表达式中或禁用大段代码时很有用。
出现在顶级声明之前的注释，
没有插入换行符，
被认为是记录声明本身。
这些“文档注释”是给定 Go 包或命令的主要文档。
有关文档注释的更多信息，
请参阅“Go 文档注释”。
命名 命名在 Go 语言中和在任何其他语言中一样重要。
它们甚至具有语义效应：名称在包外的可见性取决于其首字母是否为大写。
因此，值得花一些时间讨论 Go 程序中的命名约定。
包名。当导入一个包时，
包名称成为内容的访问器。
导入 "bytes" 后，导入包可以引用 bytes.Buffer 。
如果每个使用该包的人都可以使用相同的名称来引用其内容，这将很有帮助，
这意味着包名应该好：简短，
简洁，
令人回味的。
按照惯例，
包名使用小写字母，
单字名称；
不应该需要下划线或混合大小写。
尽量简洁，
因为使用你的包的每个人都会输入这个名字。
并且不要先验地担心冲突。
包名只是导入的默认名称；
它不必在所有源代码中都是唯一的，
并且在极少数发生冲突的情况下，导入包可以选择一个不同的名称在本地使用。
无论如何，
混淆的情况很少见，因为导入中的文件名决定了正在使用的包。
另一个惯例是包名是其源目录的基本名称；
src/encoding/base64 中的包被导入为 "encoding/base64"，但名称为 base64。
不是 encoding_base64 也不是 encodingBase64 。
包的导入者将使用该名称来引用其内容。
因此，包中导出的名称可以利用这一事实来避免重复。
(不要使用 import .
符号，
这可以简化必须在其测试包之外运行的测试，
但应尽量避免。
) 例如，
bufio 包中的缓冲读取器类型称为 Reader。
不是 BufReader，
因为用户将其视为 bufio.Reader，
这是一个清晰的，
简洁的名称。
此外，
因为导入的实体总是通过它们的包名来寻址，
bufio.Reader 与 io.Reader 不冲突。
类似地，
用于创建 ring.Ring 新实例的函数（在 Go 中是构造函数的定义）通常被称为 NewRing。
但由于 Ring 是包中唯一导出的类型，
并且由于该包被称为 ring，
所以它就叫做 New 。
包的哪些客户端将其视为 ring.New 。
使用包结构来帮助你选择好的名称。
另一个简短的例子是 once.Do ;
once.Do(setup) 的可读性很好，写成 once.DoOrWaitUntilDone(setup) 并不会更好。
长名称不会自动使事物更具可读性。
一个有用的文档注释通常比一个超长的名称更有价值。
Getters Go 不提供对 getter 和 setter 的自动支持。
自己提供 getter 和 setter 没有什么问题，
而且通常这样做是合适的，
但将 Get 放入 getter 的名称中既不符合语言习惯，也没有必要。
如果你有一个名为 owner 的字段（小写），
未导出)，
getter 方法应该被称为 Owner (大写)。
已导出)，
不是 GetOwner 。
使用大写名称进行导出提供了一个钩子，用于区分字段和方法。
一个设置函数，
如果需要，
可能会被调用 SetOwner。
这两个名称在实践中都很容易理解：owner := obj.Owner() 如果 owner !
= user { obj.SetOwner(user) } 接口名称 按照惯例，
单方法接口以方法名加上 -er 后缀或类似的修改来命名，以构造一个施事名词：Reader，
Writer，
格式化器 ,
CloseNotifier 等。 有很多这样的名称，尊重它们以及它们捕获的函数名称是有益的。
读取 ,
写 ,
关闭，
刷新，
String 等等具有规范的签名和含义。
为了避免混淆，
除非你的方法具有相同的签名和含义，否则不要给它起这些名字。
相反地，
如果你的类型实现了一个方法，该方法与一个众所周知的类型上的方法具有相同的含义，
给它相同的名称和签名；
调用你的字符串转换器方法为 String 而不是 ToString 。
MixedCaps 最后，
Go 的惯例是使用 MixedCaps 或 mixedCaps 而不是下划线来编写多字名称。
像 C 语言一样的分号，
Go 的形式语法使用分号来结束语句，
但与 C 不同的是，
这些分号不会出现在源代码中。
相反，词法分析器使用一个简单的规则在扫描时自动插入分号，
所以输入文本基本上没有这些分号。
规则是这样的。
如果换行符前的最后一个标记是标识符（包括诸如 int 和 float64 之类的词），
一个基本的字面量，如数字或字符串常量，
或者标记 break continue fallthrough return ++ -- ) } 之一，则词法分析器始终在该标记后插入分号。
这可以概括为：
“如果换行符出现在可以结束语句的标记之后，
插入分号”。
在右括号之前也可以省略分号，
因此，像 go func() { for { dst <- <-src } }() 这样的语句不需要分号。
地道的 Go 程序只有在 for 循环子句等地方才有分号，
为了分隔初始化器，
条件，
以及延续元素。
它们也是在一行上分隔多个语句所必需的，
你应该那样写代码。
分号插入规则的一个后果是，不能将控制结构（if，
for，
开关，
或 select）的左大括号放在下一行。
如果你这样做，
将在大括号前插入一个分号，
这可能会导致不良影响。
像这样写：如果 i < f() { g() }，不要像这样写：如果 i < f() // 错误！
{ // 错误！
g() } 控制结构 Go 的控制结构与 C 的控制结构相关，但在重要方面有所不同。
没有 do 或 while 循环
只有一个稍微通用的 for ;
switch 更灵活；
if 和 switch 接受一个可选的初始化语句，类似于 for 的初始化语句;
break 和 continue 语句可以使用可选标签来标识要中断或继续的内容；
并且有新的控制结构，包括类型开关和一个多路通信复用器，
选择。
语法也略有不同：没有括号，并且主体必须始终用大括号分隔。
If 在 Go 中，一个简单的 if 语句如下所示：if x > 0 { return y } 强制使用大括号鼓励将简单的 if 语句写在多行上。
无论如何，这样做是一种好的风格，
尤其是当主体包含诸如 return 或 break 之类的控制语句时。
由于 if 和 switch 接受初始化语句，
因此，常见的是使用初始化语句来设置局部变量。
如果 err := file.Chmod(0664);
错误！
= nil { log.Print(err) return err } 在 Go 库中，
你会发现，当一个 if 语句没有流入到下一个语句时——也就是说，
主体以 break 结束，
continue，
goto，
或者返回——省略了不必要的 else。
f,
err := os.Open(name) 如果 err != nil { return err } codeUsing(f) 这是一个常见情况的例子，代码必须防范一系列错误条件。
= nil { return err } codeUsing(f) 这是一个常见情况的示例，在这种情况下，代码必须防范一系列错误情况。
如果成功的控制流顺着页面向下运行，代码的可读性会很好，
在出现时消除错误情况。
由于错误情况往往以 return 语句结尾，
生成的代码不需要 else 语句。
f,
err := os.Open(name) 如果 err != nil { return err } codeUsing(f) 这是一个常见情况的例子，代码必须防范一系列错误条件。
= nil { return err } d,
err := f.Stat() 如果 err !
= nil { f.Close() return err } codeUsing(f,
d) 重新声明和重新赋值 题外话：上一节中的最后一个示例演示了 := 短声明形式的工作方式的细节。
调用 os.Open 的声明如下：
f,
err := os.Open(name) 这个语句声明了两个变量，
f 和 err 。
几行之后，
调用 f.Stat 如下：
d,
err := f.Stat() 看起来像是声明了 d 和 err 。
注意
虽然，
err 出现在两个语句中。
这种重复是合法的：err 由第一个语句声明，
但仅在第二个语句中重新赋值。
这意味着对 f.Stat 的调用会使用上面声明的现有 err 变量。
只是给它赋了一个新值。
在 := 声明中，即使变量 v 已经被声明，它也可以出现，
前提是：此声明与 v 的现有声明在同一作用域中（如果 v 已在外部作用域中声明，
该声明将创建一个新变量Â§)，
初始化中对应的值可以分配给 v 。
并且至少还有一个变量是由该声明创建的。
这种不寻常的属性纯粹是实用主义。
使得使用单个 err 值变得容易，
例如，
在一个长的 if-else 链中。
你会经常看到它被使用。
Â§ 这里值得注意的是，在 Go 中，函数参数和返回值的范围与函数体相同。
即使它们在词法上出现在包围函数体的花括号之外。
Go 的 for 循环与 C 的类似，但不完全相同。
它统一了 for 和 while，并且没有 do-while。
有三种形式，
其中只有一个包含分号。
"// 像 C 语言的 for 循环 for init;
条件；
post { } // 类似 C 语言的 while 循环条件 { } // 类似 C 语言的 for 循环(;
) for { } 短声明可以很容易地在循环中声明索引变量。
sum := 0 for i := 0;
i < 10;
i++ { sum += i } 如果你正在循环一个数组，
切片
字符串
或映射，
或从通道读取，
range 子句可以管理循环。
对于键，
value := range oldMap { newMap[key] = value } 如果你只需要 range 中的第一个元素（键或索引），
省略第二个： for key := range m { if key.expired() { delete(m,
key) } } 如果你只需要 range 中的第二个元素（值），
使用空白标识符
下划线，
丢弃第一个：sum := 0 for _,
value := range array { sum += value } 空白标识符有很多用途，
如后续章节所述。
对于字符串，
range 为您做了更多的工作，
通过解析 UTF-8 来分解各个 Unicode 代码点。 错误的编码会消耗一个字节并产生替换符文 U+FFFD。
(名称（带有相关的内置类型）rune 是 Go 术语，表示单个 Unicode 代码点。
有关详细信息，请参阅语言规范。
") pos 的循环，
char := range "æ—¥æœ¬\x80èªž" { // \x80 是非法的 UTF-8 编码 fmt.Printf("character %#U starts at byte position %d\n",
char,
pos) } 打印 character U+65E5 'æ—¥' 从字节位置 0 开始 character U+672C 'æœ¬' 从字节位置 3 开始 character U+FFFD 'ï¿½' 从字节位置 6 开始 character U+8A9E 'èªž' 从字节位置 7 开始 最后，
Go 没有逗号运算符，++ 和 -- 是语句而不是表达式。
因此，如果你想在一个 for 循环中运行多个变量，你应该使用并行赋值（尽管这排除了 ++ 和 --）。
// 反转 for i,
j := 0，
len(a)-1;
i < j;
我，
j = i+1，
j-1 { a[i]，
a[j] = a[j]，
a[i] } Go 的 switch 比 C 的更通用。
表达式不必是常量，甚至不必是整数，
这些案例从上到下进行评估，直到找到匹配项，
如果 switch 没有表达式，则它切换为 true。
因此，将 if - else - if - else 链写成 switch 是可能的，而且是符合语言习惯的。
func unhex(c byte) byte { switch { case '0' <= c && c <= '9': return c - '0' case 'a' <= c && c <= 'f': return c - 'a' + 10 case 'A' <= c && c <= 'F': return c - 'A' + 10 } return 0 } 没有自动 fall through，
但是 case 可以用逗号分隔的列表表示。
func shouldEscape(c byte) bool { switch c { case ' ',
'%'：返回真} 返回假} 虽然它们在 Go 中不像其他一些类 C 语言中那么常见，
break 语句可以用来提前终止 switch 语句。
有时，
虽然，
有必要跳出外围循环，
不是 switch，
在 Go 中，可以通过在循环上放置一个标签并“break”到该标签来实现。
这个例子展示了这两种用法。
循环：for n := 0;
n < len(src);
'n += size { switch { case src[n] < sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] < sizeTwo: if n+1 >= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]<<shift) } } 当然，'
continue 语句也接受一个可选标签，但它只适用于循环。
为了结束本节，
这是一个使用两个 switch 语句的字节切片比较例程：// Compare 返回一个整数，比较两个字节切片，
// 按字典顺序。
// 如果 a == b，则结果为 0
如果 a < b，则为 -1
如果 a > b，则为 +1 func Compare(a,
b []byte) int { for i := 0;
i < len(a) && i < len(b);
i++ { switch { case a[i] > b[i]: return 1 case a[i] < b[i]: return -1 } } switch { case len(a) > len(b): return 1 case len(a) < len(b): return -1 } return 0 } 类型开关 A switch 也可以用来发现接口变量的动态类型。
这种类型开关使用类型断言的语法，其中括号内包含关键字 type。
如果 switch 在表达式中声明了一个变量，
该变量在每个子句中都将具有相应的类型。
在这种情况下，重用名称也是惯用的做法，
实际上，它声明了一个新变量，该变量具有相同的名称，但在每种情况下都具有不同的类型。
var t interface{} t = functionOfSomeType() switch t := t.
(类型) { default: fmt.Printf("意外的类型 %T\n",
t) // %T 打印 t 的类型 case bool: fmt.Printf("布尔值 %t\n",
t) // t 的类型是 bool case int: fmt.Printf("整数 %d\n",
t) // t 的类型是 int case *bool: fmt.Printf("指向布尔值的指针 %t\n",
*t) // t 的类型是 *bool case *int: fmt.Printf("指向整数的指针 %d\n",
*t) // t 的类型是 *int } 函数 多重返回值 Go 的一个不寻常的特性是函数和方法可以返回多个值。
这种形式可以用来改进 C 程序中的几个笨拙的习惯用法：带内错误返回，例如 EOF 的 -1，以及修改按地址传递的参数。
在 C 中，
一个写入错误通过一个负计数来表示，错误代码隐藏在一个易失的位置。
在 Go 语言中，
Write 可以返回一个计数和一个错误：“是的，
你写入了一些字节，但并非全部，因为你已填满设备”。
os 包中文件的 Write 方法的签名是：func (file *File) Write(b []byte) (n int,
err error)，正如文档所说，
当 n != len(b) 时，它返回写入的字节数和一个非 nil 错误。
= len(b) .
这是一种常见的风格；
更多示例请参见错误处理部分。
类似的方法避免了传递指向返回值的指针来模拟引用参数的需要。
这是一个简单的函数，用于从字节切片中的某个位置获取数字，
返回数字和下一个位置。
func nextInt(b []byte,
i int) (int,
int) { for ;
i < len(b) && !
isDigit(b[i]);
i++ { } x := 0 for ;
i < len(b) && isDigit(b[i]);
i++ { x = x*10 + int(b[i]) - '0' } return x,
i } 您可以使用它来扫描输入切片 b 中的数字，如下所示：for i := 0;
i < len(b);
{ x,
i = nextInt(b,
i) fmt.Println(x) } 命名结果参数 Go 函数的返回或结果“参数”可以被赋予名称并像普通变量一样使用，
就像传入的参数一样。
当命名时，
当函数开始时，它们被初始化为各自类型的零值；
如果函数执行不带参数的 return 语句，
则结果参数的当前值将用作返回值。
名称不是强制性的，但它们可以使代码更短更清晰：它们是文档。
如果我们命名 nextInt 的结果，那么很明显哪个返回的 int 是哪个。
函数 nextInt(b []byte,
pos int) (value,
nextPos int) { 因为命名结果被初始化并绑定到一个不加修饰的返回，
它们可以简化和阐明。
这是一个很好地使用它们的 io.ReadFull 版本：func ReadFull(r Reader,
buf []byte) (n int,
err error) { for len(buf) > 0 && err == nil { var nr int nr,
err = r.Read(buf) n += nr buf = buf[nr:] } return } Defer Go 的 defer 语句安排一个函数调用（延迟函数）在执行 defer 的函数返回之前立即运行。
这是一种不寻常但有效的方法来处理诸如必须释放的资源的情况，无论函数采用哪种返回路径。
典型的例子是解锁互斥锁或关闭文件。
// Contents 以字符串形式返回文件内容。
func Contents(filename string) (string,
error) { f,
err := os.Open(filename) if err != nil { return "", err } defer f.Close() // f.Close 会在我们完成时运行。
= nil { return "",
err } defer f.Close() // f.Close 将在我们完成时运行。
var result []byte buf := make([]byte,
变量 result []byte buf := make([]byte,
100) for { n,
buf[0:n]...
err := f.Read(buf[0:]) result = append(result,
如果 err !
= nil { 如果 err == io.EOF { 中断 } 返回 "",
err // 如果我们在这里返回，f 将被关闭。
} } 返回 string(result),
nil // 如果我们在这里返回，f 将被关闭。
} 延迟调用像 Close 这样的函数有两个优点。
首先，
它保证你永远不会忘记关闭文件，
如果稍后编辑该函数以添加新的返回路径，则很容易犯这个错误。
其次，
这意味着 close 靠近 open。
这样比将其放在函数末尾要清晰得多。
延迟函数的参数（如果该函数是一个方法，则包括接收者）在 defer 执行时进行求值，
而不是在调用执行时。
除了避免担心函数执行时变量值发生变化之外，
这意味着单个延迟调用点可以延迟多个函数执行。
这是一个愚蠢的例子。
for i := 0;
i < 5;
i++ { defer fmt.Printf("%d ",
i) } Deferred functions are executed in LIFO order,
so this code will cause 4 3 2 1 0 to be printed when the function returns.
一个更合理的例子是通过程序跟踪函数执行的简单方法。
我们可以编写几个简单的跟踪例程，如下所示：func trace(s string) { fmt.Println("entering:",
s) } func untrace(s string) { fmt.Println("leaving:",
s) } // 像这样使用它们：func a() { trace("a") defer untrace("a") // 做一些事情....
} 我们可以做得更好，利用延迟函数的参数在 defer 执行时被计算的事实。
追踪例程可以设置取消追踪例程的参数。
这个例子：func trace(s string) string { fmt.Println("entering:",
s) return s } func un(s string) { fmt.Println("leaving:",
s) } func a() { defer un(trace("a")) fmt.Println("in a") } func b() { defer un(trace("b")) fmt.Println("in b") a() } func main() { b() } 打印 entering: b in b entering: a in a leaving: a leaving: b 对于习惯了其他语言的块级资源管理的程序员来说，
defer 似乎很奇怪，
但它最有趣和最强大的应用恰恰来自于它不是基于块而是基于函数的事实。
在关于 panic 和 recover 的章节中，我们将看到它的另一种可能性。
Go 中的 new 有两个分配原语进行数据分配，
内置函数 new 和 make 。
它们做不同的事情并应用于不同的类型，
这可能会让人感到困惑，
但规则很简单。
让我们先谈谈 new。
这是一个分配内存的内置函数，
但与某些其他语言中的同名函数不同，它不会初始化内存，
它只是将其归零。
也就是说，
new(T) 为 T 类型的新项分配零存储空间并返回其地址，
*T 类型的值。
用 Go 术语来说，
它返回一个指向新分配的 T 类型零值的指针。
由于 new 返回的内存已置零，
在设计数据结构时，安排每种类型的零值无需进一步初始化即可使用是很有帮助的。
这意味着数据结构的用户可以使用 new 创建一个并立即开始工作。
例如，
bytes.Buffer 的文档说明“Buffer 的零值是一个可以使用的空缓冲区”。
类似地，
sync.Mutex 没有显式的构造函数或 Init 方法。
相反，
sync.Mutex 的零值被定义为一个未锁定的互斥锁。
零值有用的特性是可传递的。
考虑一下这个类型声明。
type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } SyncedBuffer 类型的值在分配或声明后也可以立即使用。
在下一个代码片段中，
p 和 v 都可以正常工作，无需进一步安排。
p := new(SyncedBuffer) // 类型 *SyncedBuffer var v SyncedBuffer // 类型 SyncedBuffer 构造函数和复合字面量 有时零值不够好，需要一个初始化构造函数，
就像这个从 os 包派生的例子一样。
func NewFile(fd int,
name string) *File { if fd < 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } 这里有很多样板代码。
我们可以使用复合字面量来简化它，
这是一个表达式，每次计算时都会创建一个新实例。
func NewFile(fd int,
name string) *File { if fd < 0 { return nil } f := File{fd,
姓名，
无，
0} 返回 &f } 请注意，
与 C 不同，
返回局部变量的地址是完全可以的；
与变量关联的存储在函数返回后仍然存在。
事实上，
每次计算复合字面量的地址时，都会分配一个新的实例，
所以我们可以将最后两行合并。
return &File{fd,
姓名，
无，
0} 复合字面量的字段按顺序排列，并且必须全部存在。
然而，
通过将元素显式标记为 field : value 对，
初始化器可以以任何顺序出现，
缺少的那些将保留为各自的零值。
因此，我们可以说返回 &File{fd: fd,
name: name} 作为一个限制情况，
如果一个组合字面量根本不包含任何字段，
它会为该类型创建一个零值。
表达式 new(File) 和 &File{} 是等价的。
复合字面量也可以为数组创建，
切片,
和 map，
字段标签是适当的索引或 map 键。
在这些例子中，
无论 Enone 的值是多少，初始化都能正常工作
Eio
以及 Einval
只要它们是不同的。
a := [...
]string {Enone: "没有错误",
Eio: "Eio",
Einval：“无效参数”} s := []string {Enone：“无错误”，
Eio：“Eio”，
Einval：“无效参数”} m := map[int]string{Enone：“无错误”，
Eio：“Eio”，
Einval：“无效参数”使用 make 进行分配，返回到分配。
内置函数 make(T,
args) 的作用与 new(T) 不同。
它创建切片，
地图，
并且仅限于通道，
它返回类型 T（而不是 *T）的已初始化（非零）值。
区分的原因是这三种类型代表，
在底层，
引用必须在使用前初始化的数据结构。
切片，
例如，
是一个三项描述符，包含指向数据（在数组内部）的指针、
长度，
以及容量，
并且直到这些项目被初始化，
切片为 nil。
对于切片，
地图，
和通道，
make 初始化内部数据结构并准备好供值使用。
例如，
make([]int,
100) 分配一个包含 100 个整数的数组，然后创建一个切片结构，其长度为 10，容量为 100，指向数组的前 10 个元素。
（创建切片时，
可以省略容量；
有关更多信息，请参见切片部分。
）相反，
new([]int) 返回一个指向新分配的、
零值切片结构的指针，
也就是说，
指向一个 nil 切片值的指针。
这些例子说明了 new 和 make 之间的区别。
var p *[]int = new([]int) // 分配切片结构;
*p == nil;
很少有用 var v []int = make([]int,
100) // 切片 v 现在指向一个包含 100 个整数的新数组 // 不必要的复杂：var p *[]int = new([]int) *p = make([]int,
100) // 符合语言习惯：v := make([]int,
100) 请记住，make 仅适用于 map、
切片和通道，并且不返回指针。
要获得显式指针，请使用 new 分配或显式获取变量的地址。
数组在规划内存的详细布局时非常有用，有时可以帮助避免分配，
但它们主要是切片的构建块，
这是下一节的主题。
为了给这个主题打下基础，
这里有一些关于数组的介绍。
Go 和 C 中数组的工作方式存在重大差异。
在 Go 中，
数组是值。
将一个数组赋值给另一个数组会复制所有元素。
特别是，
如果将数组传递给函数，
它将收到数组的副本，
而不是指向它的指针。
数组的大小是其类型的一部分。
[10]int 和 [20]int 类型是不同的。
value 属性可能很有用，但也很昂贵；
如果你想要类似 C 的行为和效率，
你可以传递一个指向数组的指针。
func Sum(a *[3]float64) (sum float64) { for _,
v := range *a { sum += v } return } 数组 := [...
]float64{7.0,
9.1} x := Sum(&array) // 注意显式的取地址运算符 但即使是这种风格也不是地道的 Go 语言。
使用切片代替。
切片 切片包装数组以提供更通用的，
强大的，
以及到数据序列的便捷接口。
除了具有显式维度的项目（如变换矩阵）外，
Go 中的大多数数组编程都是使用切片而不是简单数组来完成的。
切片保存对底层数组的引用，
并且如果你将一个切片赋值给另一个切片，
两者都指向同一个数组。
如果一个函数接受一个切片参数，
它对切片元素所做的更改对调用者是可见的，
类似于传递指向底层数组的指针。
因此，Read 函数可以接受切片参数，而不是指针和计数；
切片中的长度设置了读取多少数据的上限。
这是 os 包中 File 类型的 Read 方法的签名：func (f *File) Read(buf []byte) (n int,
err error) 该方法返回读取的字节数和一个错误值，
如果有的话。
要读取到更大的缓冲区 buf 的前 32 个字节，
对缓冲区进行切片（此处用作动词）。
n,
err := f.Read(buf[0:32]) 这种切片操作很常见且很有效。
事实上，
暂且不考虑效率，
以下代码片段也会读取缓冲区的前 32 个字节。
var n int var err error for i := 0;
i < 32;
i++ { nbytes,
ext: e := f.Read(buf[i:i+1]) // 读取一个字节。
如果 nbytes == 0 或 e !，则 n += nbytes
= nil { err = e break } } 只要切片仍在底层数组的限制范围内，就可以更改其长度；
只需将其分配给自身的一个切片即可。
切片的容量，
可以通过内置函数 cap 访问，
报告切片可能假定的最大长度。
这是一个将数据附加到切片的函数。
如果数据超过容量，
则重新分配切片。
返回结果切片。
该函数使用了 len 和 cap 在应用于 nil 切片时是合法的这一特性，
并返回 0。
func Append(slice,
data []byte) []byte { l := len(slice) if l + len(data) > cap(slice) { // 重新分配 // 分配所需数量的两倍，
为了未来的增长。
newSlice := make([]byte,
(l+len(data))*2) // The copy function is predeclared and works for any slice type.
copy(newSlice,
slice) slice = newSlice } slice = slice[0:l+len(data)] copy(slice[l:],
据) 返回切片 } 我们必须在之后返回切片，因为，
尽管 Append 可以修改 slice 的元素，
但切片本身（保存指针的运行时数据结构，
长度，
和容量）是按值传递的。
将内容附加到切片的想法非常有用，因此它被内置的 append 函数捕获。
要理解该函数的设计，
虽然，
我们需要更多信息，
所以我们稍后会再讨论它。
二维切片 Go 的数组和切片是一维的。
要创建等效于 2D 数组或切片的内容，
必须定义数组的数组或切片的切片，
像这样：type Transform [3][3]float64 // 一个 3x3 数组，
实际上是一个数组的数组。
type LinesOfText [][]byte // 字节切片的切片。
因为切片是可变长度的，
所以每个内部切片都可以有不同的长度。
这可能是一种常见情况，
就像我们的 LinesOfText 示例一样：每行都有独立的长度。
text: text := LinesOfText{ []byte("现在是时候了"),
[]byte("为了所有优秀的 gophers"),
[]byte("为派对带来一些乐趣。"
} 有时需要分配一个二维切片，
这种情况可能在处理像素扫描线时出现，
例如。
有两种方法可以实现这一点。
一种方法是独立分配每个切片；
另一种方法是分配一个单独的数组，并将各个切片指向它。
具体使用哪种方法取决于你的应用程序。
如果切片可能会增长或缩小，
它们应该被独立分配，以避免覆盖下一行；
如果不是，
以单次分配构造对象可能更有效率。
作为参考，
这里是两种方法的草图。
首先，
一次一行：// 分配顶层切片。
picture := make([][]uint8,
YSize) // 每个 y 单位一行。
// 循环遍历行，
为每一行分配切片。
for i := range picture { picture[i] = make([]uint8,
XSize) } 现在作为一个分配，
切割成行：// 分配顶级切片，
和以前一样。
picture := make([][]uint8,
YSize) // 每个 y 单位一行。
// 分配一个大的切片来容纳所有像素。
pixels := make([]uint8,
XSize*YSize) // 即使 picture 是 [][]uint8，也具有 []uint8 类型。
// 遍历行，
从剩余像素切片的开头切分每一行。
for i := range picture { picture[i],
pixels = pixels[:XSize],
pixels[XSize:] } 映射 映射是一种方便而强大的内置数据结构，它将一种类型的值（键）与另一种类型的值（元素或值）相关联。
键可以是定义了相等运算符的任何类型，
例如整数、
浮点数和复数、
字符串
指针，
接口（只要动态类型支持相等性）。
结构体和数组。
切片不能用作 map 的键，
因为它们没有定义相等性。
和切片一样，
映射保存对底层数据结构的引用。
如果您将映射传递给更改映射内容的函数，
更改将在调用者中可见。
可以使用通常的复合字面量语法（带有冒号分隔的键值对）来构造映射，
因此在初始化期间很容易构建它们。
var timeZone = map[string]int{ "UTC": 0*60*60,
"EST": -5*60*60,
"CST": -6*60*60,
"MST": -7*60*60,
"PST": -8*60*60,
} 分配和获取 map 值在语法上看起来就像对数组和切片执行相同的操作，只是索引不需要是整数。
offset := timeZone["EST"] 尝试获取 map 中不存在的键的 map 值将返回 map 中条目类型的零值。
例如，
如果 map 包含整数，
查找不存在的键将返回 0。
集合可以实现为值类型为 bool 的 map。
将 map 条目设置为 true，以将值放入集合中，
然后通过简单的索引来测试它。
attended := map[string]bool{ "Ann": true,
"Joe": true,
} if attended[person] { // 如果 person 不在 map 中，则为 false fmt.Println(person,
"在会议上）} 有时您需要区分缺失的条目和零值。"
是否有“UTC”的条目，还是因为该条目根本不在 map 中，所以为 0？
您可以使用一种多重赋值的形式来区分。
var seconds int var ok bool seconds,
ok = timeZone[tz] 出于显而易见的原因，这被称为“逗号 ok” 惯用法。
在这个例子中，
如果 tz 存在，
seconds 将被适当地设置，并且 ok 将为 true；
如果不是，
秒数将被设置为零，并且 ok 将为 false。
这是一个将它们组合在一起并带有良好错误报告的函数：func offset(tz string) int { if seconds,
ok := timeZone[tz];
好的 { return seconds } log.Println(\"未知时区：\",
tz) return 0 } 要在不担心实际值的情况下测试地图中是否存在，
你可以使用空白标识符 ( _ ) 代替通常用于该值的变量。
present := timeZone[tz] 要删除地图条目，
使用内置函数 delete，
其参数是要删除的 map 和键。
即使该键已从 map 中删除，这样做也是安全的。
delete(timeZone,
"PDT") // 现在是标准时间 Go 中的格式化打印使用类似于 C 的 printf 系列的风格，但更丰富、更通用。
这些函数存在于 fmt 包中，并且具有大写的名称：fmt.Printf ,
fmt.Fprintf ,
fmt.Sprintf 等等。
字符串函数（Sprintf 等）
返回一个字符串，而不是填充提供的缓冲区。
您不需要提供格式字符串。
对于每个 Printf ，
Fprintf 和 Sprintf 还有另一对函数，
例如 Print 和 Println。
这些函数不接受格式字符串，而是为每个参数生成默认格式。
Println 版本还在参数之间插入一个空格，并在输出中附加一个换行符，而 Print 版本仅当两侧的操作数都不是字符串时才添加空格。
在这个例子中，每一行都会产生相同的输出。
fmt.Printf("你好 %d\n",
23) fmt.Fprint(os.Stdout,
"你好 ",
") fmt.Println("你好",
23) fmt.Println(fmt.Sprint(\"你好 \",
23)) 格式化的打印函数 fmt.Fprint 及其类似函数将任何实现 io.Writer 接口的对象作为第一个参数；
变量 os.Stdout 和 os.Stderr 是常见的实例。
在这里，事情开始与 C 语言有所不同。
首先，
数字格式（如%d）不接受有符号或大小的标志；
而是，
打印例程使用参数的类型来决定这些属性。
var x uint64 = 1<<64 - 1 fmt.Printf("%d %x;
"%d %x\n",
x,
x,
int64(x),
int64(x)) 打印 18446744073709551615 ffffffffffffffff;
-1 -1 如果你只是想要默认转换，
例如整数的十进制，
你可以使用通配符格式 %v (代表“值”)；
结果与 Print 和 Println 产生的结果完全相同。
此外，
该格式可以打印任何值，
甚至数组，
切片,
结构体,
和映射。
这是上一节中定义的时区映射的打印语句。
fmt.Printf("%v\n",
时区）// 或者直接使用 fmt.Println(timeZone)，输出结果为：map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]。 对于 map，
Printf 及其友元函数会按键对输出进行字典排序。
打印结构体时，
修改后的格式 %+v 使用字段名称注释结构的字段，
并且对于任何值，备用格式 %#v 以完整的 Go 语法打印该值。
type T struct { a int b float64 c string } t := &T{ 7,
"abc\tdef" } fmt.Printf("%v\n",
t) fmt.Printf("%+v\n",
t) fmt.Printf("%#v\n",
t) fmt.Printf("%#v\n",
timeZone) 打印 &{7 -2.35 abc def} &{a:7 b:-2.35 c:abc def} &main。
T{a:7,
b:-2.35,
c:"abc\tdef"} map[string]int{"CST":-21600,
"EST":-18000,
"MST":-25200,
"PST":-28800,
"UTC":0} （请注意这些符号。）
) 当应用于字符串或 []byte 类型的值时，该带引号的字符串格式也可通过 %q 获得。
如果可能，备用格式 %#q 将使用反引号。
（%q 格式也适用于整数和 runes，
产生一个单引号的 rune 常量。
) 此外，
%x 可以处理字符串、
字节数组和字节切片，以及整数，
生成一个长的十六进制字符串，
并且在格式中使用空格 ( %Â x ) 会在字节之间放置空格。
另一个方便的格式是 %T，
它会打印值的类型。
fmt.Printf("%T\n",
timeZone) 会打印 map[string]int。 如果你想控制自定义类型的默认格式，
所需要的只是在该类型上定义一个具有 String() string 签名的方法。
对于我们简单的类型 T，
可能看起来像这样。
func (t *T) String() string { return fmt.Sprintf("%d/%g/%q",
t。
a，
t。
b，
t。
c) } fmt.Printf("%v\n",
以 7/-2.35/"abc\tdef" 的格式打印 t)（如果需要打印 T 类型的值以及指向 T 的指针，
String 的接收器必须是值类型；
此示例使用指针是因为对于结构体类型来说，这样做更有效且更符合习惯用法。
有关指针与值接收器的更多信息，请参见下面的部分。
) 我们的 String 方法能够调用 Sprintf，因为打印例程是完全可重入的，并且可以这样包装。
关于这种方法，有一个重要的细节需要理解，
然而：不要以会无限循环调用你的 String 方法的方式，通过调用 Sprintf 来构建 String 方法。
如果 Sprintf 调用尝试直接将接收者作为字符串打印，就会发生这种情况，
这反过来会再次调用该方法。
这是一个常见且容易犯的错误，
正如此示例所示。
type MyString string func (m MyString) String() string { return fmt.Sprintf("MyString=%s",
m) // 错误：将永远重复。
} 这也很容易修复：将参数转换为基本的字符串类型，
它没有该方法。
| type MyString string func (m MyString) String() string { return fmt.Sprintf("MyString=%s", string(m)) // OK: 注意转换。
string(m)) // OK: 注意转换。
} 在初始化部分，我们将看到另一种避免这种递归的技术。
另一种打印技术是将打印例程的参数直接传递给另一个这样的例程。
Printf 的签名使用了类型 ...
interface{} 作为它的最后一个参数，用于指定在格式化字符串之后可以出现任意数量的（任意类型的）参数。
func Printf(format string,
v ...interface{}) (n int,
err error) { 在 Printf 函数中，
err error) { 在 Printf 函数中，
v 的行为类似于 []interface{} 类型的变量，但如果将其传递给另一个可变参数函数，
它的行为类似于常规的参数列表。
这是我们上面使用的函数 log.Println 的实现。
它将其参数直接传递给 fmt.Sprintln 以进行实际格式化。
// Println 以 fmt.Println 的方式打印到标准日志记录器。
func Println(v ...
interface{}) { std.Output(2,
fmt.Sprintln(v...
)) // Output 接受参数 (int,
string) } 我们写 ...
在嵌套调用 Sprintln 中，我们在 v 后面加上 ... 以告诉编译器将 v 视为参数列表；
否则，它只会将 v 作为单个切片参数传递。
打印还有更多我们在这里没有涉及的内容。
详情请参阅 fmt 包的 godoc 文档。
顺便说一句，
a ...
参数可以是特定类型，
例如 ...
用于 min 函数的 int，该函数选择整数列表中的最小值：func Min(a ...
int) int { min := int(^uint(0) >> 1) // 最大的 int for _,
i := range a { if i < min { min = i } } return min } Append 现在我们有了解释 append 内置函数设计的缺失部分。
append 的签名与上面我们自定义的 Append 函数不同。
示意地，
就像这样：func append(slice [] T ,
元素 ...
T ) [] T 其中 T 是任何给定类型的占位符。
你实际上不能在 Go 中编写一个函数，其中类型 T 由调用者确定。
这就是为什么 append 是内置的：它需要编译器的支持。
append 的作用是将元素追加到切片的末尾并返回结果。
需要返回结果，因为，
就像我们手写的 Append 一样，
底层数组可能会发生变化。
这个简单的例子 x := []int{1,
3} x = append(x,
6) fmt.Println(x) 打印 [1 2 3 4 5 6] 。
所以 append 的工作方式有点像 Printf，
收集任意数量的参数。
但是，如果我们想做我们 Append 所做的事情，并将一个切片附加到另一个切片，该怎么办？
简单：使用 ...
在调用点，
就像我们在上面对 Output 的调用中所做的那样。
这个代码片段产生与上面相同的输出。
xt: x := []int{1,
3} y := []int{4,
6} x = append(x,
y...
) fmt.Println(x) Without that ...
它不会编译，因为类型会出错；
y 不是 int 类型。
初始化 虽然表面上看起来与 C 或 C++ 中的初始化没有太大区别，
Go 中的初始化功能更强大。
复杂的结构可以在初始化期间构建，并且已初始化对象之间的排序问题，
甚至在不同的包之间，
都能得到正确的处理。
常量 Go 中的常量就是常量。
它们在编译时创建，
即使在函数中定义为局部变量，
并且只能是数字，
字符 (rune)，
字符串或布尔值。
由于编译时限制，
定义它们的表达式必须是常量表达式，
可以由编译器评估。
例如，
1<<3 是一个常量表达式，
而 math.Sin(math.Pi/4) 不是，因为对 math.Sin 的函数调用需要在运行时发生。
在 Go 语言中，
枚举常量是使用 iota 枚举器创建的。
由于 iota 可以是表达式的一部分，并且表达式可以被隐式重复，
因此很容易构建复杂的数值集。
type ByteSize float64 const ( _ = iota // 通过赋值给空白标识符来忽略第一个值 KB ByteSize = 1 << (10 * iota) MB GB TB PB EB ZB YB ) 将诸如 String 之类的方法附加到任何用户定义的类型的能力使得任意值能够自动格式化自身以进行打印。
虽然您会经常看到它应用于结构体，
这种技术也适用于标量类型，例如浮点类型（如 ByteSize）。
func (b ByteSize) String() string { switch { case b >= YB: return fmt.Sprintf("%.
2fYB",
b/YB) 如果 b >= ZB: 返回 fmt.Sprintf("%.
2fZB",
b/ZB) 如果 b >= EB: 返回 fmt.Sprintf("%.
2fEB",
b/EB) 如果 b >= PB: 返回 fmt.Sprintf("%.
2fPB"，
b/PB) 如果 b >= TB: 返回 fmt.Sprintf("%.
2fTB"，
b/TB) case b >= GB: 返回 fmt.Sprintf("%.
2fGB",
b/GB) case b >= MB: 返回 fmt.Sprintf("%.
2fMB",
b/MB) case b >= KB: 返回 fmt.Sprintf("%.
2fKB\"，
b/KB) } 返回 fmt.Sprintf("%.
2fB\"，
b) } 表达式 YB 打印为 1.00YB。
而 ByteSize(1e13) 打印为 9.09TB。
这里使用 Sprintf 来实现 ByteSize 的 String 方法是安全的（避免无限递归），不是因为转换，而是因为它使用 %f 调用 Sprintf，
这不是字符串格式：Sprintf 仅在需要字符串时才调用 String 方法，
并且 %f 需要一个浮点数值。
变量 变量可以像常量一样初始化，但是初始化器可以是在运行时计算的通用表达式。
var ( home = os.Getenv("HOME") user = os.Getenv("USER") gopath = os.Getenv("GOPATH") ) init 函数 最后，
每个源文件都可以定义自己的零元 init 函数来设置所需的任何状态。
（实际上，每个文件可以有多个 init 函数。）
）最后的意思是：init 在包中的所有变量声明都计算完它们的初始化器之后被调用，
并且只有在所有导入的包都被初始化之后，这些初始化器才会被计算。
除了不能表示为声明的初始化之外，
init 函数的一个常见用途是在实际执行开始之前验证或修复程序状态的正确性。
func init() { if user == "" { log.Fatal("$USER 未设置") } if home == "" { home = "/home/" + user } if gopath == "" { gopath = home + "/go" } // gopath 可能会被命令行中的 --gopath 标志覆盖。
flag.StringVar(&gopath,
"gopath",
gopath,
"覆盖默认 GOPATH") } 方法：指针 vs. 值 正如我们在 ByteSize 中看到的，
方法可以为任何命名类型定义（指针或接口除外）；
接收者不必是结构体。
在上面关于切片的讨论中，
我们编写了一个 Append 函数。
我们可以将其定义为切片的方法。
为了做到这一点，
我们首先声明一个命名类型，我们可以将该方法绑定到该类型，
然后使该方法的接收者成为该类型的值。
type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { // 函数体与上面定义的 Append 函数完全相同。
} 这仍然需要该方法返回更新后的切片。
我们可以通过重新定义该方法，使其接受指向 ByteSlice 的指针作为接收者，来消除这种笨拙之处，
这样该方法就可以覆盖调用者的切片。
func (p *ByteSlice) Append(data []byte) { slice := *p // 函数体如上，
没有返回值。
*p = slice } 实际上，
我们可以做得更好。
如果我们修改我们的函数，使它看起来像一个标准的 Write 方法，
像这样，
func (p *ByteSlice) Write(data []byte) (n int,
err error) { slice := *p // 和上面一样。
*p = slice return len(data),
如果 nil }，那么类型 *ByteSlice 满足标准接口 io.Writer，
这很方便。
例如，
我们可以打印到其中。
var b ByteSlice fmt.Fprintf(&b,
"This hour has %d days\n",
7) We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer .
The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values,
但指针方法只能在指针上调用。
产生此规则的原因是指针方法可以修改接收者；
在值上调用它们会导致该方法接收该值的副本，
因此任何修改都将被丢弃。
因此，该语言不允许这种错误。
这里有一个方便的例外，
虽然。
当该值是可寻址的，
语言会自动插入地址运算符，以处理在值上调用指针方法的常见情况。
在我们的例子中，
变量 b 是可寻址的，
所以我们可以直接用 b.Write 调用它的 Write 方法。
编译器会将其重写为 (&b)。
为我们写作。
顺便说一句，
在字节切片上使用 Write 的想法是 bytes.Buffer 实现的核心。
接口和其他类型 Go 中的接口提供了一种指定对象行为的方式：如果某物能做到这一点，
然后它可以在这里使用。
我们已经看到了一些简单的例子；
自定义打印机可以通过 String 方法实现，而 Fprintf 可以生成输出到任何带有 Write 方法的东西。
在 Go 代码中，只有一两个方法的接口很常见，
并且通常会根据方法给出一个名称，
例如，实现 Write 的接口通常命名为 io.Writer。
一个类型可以实现多个接口。
例如，
如果一个集合实现了 sort.Interface，它就可以通过 sort 包中的例程进行排序，
其中包含 Len()，
Less(i,
j int) bool，
并且 Swap(i,
j int) ,
并且它也可以有一个自定义的格式化程序。
在这个虚构的例子中，Sequence 同时满足了这两个条件。
type Sequence []int // sort.Interface 所需的方法。
func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i,
j int) bool { return s[i] < s[j] } func (s Sequence) Swap(i,
j int) { s[i],
s[j] = s[j],
s[i] } // Copy 返回 Sequence 的副本。
func (s Sequence) Copy() Sequence { copy := make(Sequence,
len(s)) return append(copy,
...
) } // 用于打印的方法 - 在打印前对元素进行排序。
func (s Sequence) String() string { s = s.Copy() // 复制一份；
不要覆盖参数。
sort.Sort(s) str := "[" for i,
elem := range s { // 循环是 O(NÂ²);
将在下一个示例中修复它。
if i > 0 { str += " " } str += fmt.Sprint(elem) } return str + "]" } 转换 Sequence 的 String 方法正在重新创建 Sprint 已经为切片所做的工作。
(它的复杂度也是 O(NÂ²)，
这很糟糕。)
) 如果我们在调用 Sprint 之前将 Sequence 转换为普通的 []int，我们可以分摊工作（并加快速度）。
func (s Sequence) String() string { s = s.Copy() sort.Sort(s) return fmt.Sprint([]int(s)) } 这个方法是另一种转换技术的例子，用于从 String 方法安全地调用 Sprintf。
因为如果我们忽略类型名称，这两种类型（Sequence 和 []int）是相同的，
所以它们之间可以合法转换。
转换不会创建新值，
它只是暂时表现得好像现有值具有新类型。
（还有其他合法的转换，
例如从整数到浮点数，
这确实会创建一个新值。
）在 Go 程序中，这是一种惯用法，用于转换表达式的类型以访问不同的方法集。
例如，
我们可以使用现有的类型 sort.IntSlice 将整个示例简化为：type Sequence []int // 打印方法 - 在打印之前对元素进行排序 func (s Sequence) String() string { s = s.Copy() sort.IntSlice(s).
Sort() return fmt.Sprint([]int(s)) } 现在，
而不是让 Sequence 实现多个接口（排序和打印），
我们正在使用数据项转换为多种类型（ Sequence ,
sort.IntSlice 和 []int )，
它们各自完成工作的一部分。
这在实践中不太常见，但可能有效。
接口转换和类型断言 类型开关是转换的一种形式：它们接受一个接口，并且，
对于 switch 中的每种情况，
从某种意义上说，将其转换为该案例的类型。
这是一个简化版本，展示了 fmt.Printf 下的代码如何使用类型 switch 将值转换为字符串。
如果它已经是一个字符串，
我们想要接口持有的实际字符串值，
但是如果它有一个 String 方法，我们想要调用该方法的结果。
type Stringer interface { String() string } var value interface{} // 调用者提供的值。
switch str := value.
(类型) { case string: return str case Stringer: return str.String() } 第一种情况找到一个具体的值；
第二种情况将接口转换为另一个接口。
这样混合类型完全没问题。
如果我们只关心一种类型呢？
如果我们知道该值包含一个字符串并且只想提取它呢？
单个 case 的类型开关就可以做到，
但类型断言也可以。
类型断言接受一个接口值，并从中提取指定显式类型的值。
该语法借鉴了类型开关的子句开头，
但使用显式类型而不是 type 关键字：value。
(typeName)，结果是一个具有静态类型 typeName 的新值。
该类型必须是接口所持有的具体类型，
或者值可以转换为的第二个接口类型。
要提取我们知道在值中的字符串，
我们可以这样写：str := value。
(string) 但如果结果证明该值不包含字符串，
该程序将因运行时错误而崩溃。
为了防止这种情况，
使用“逗号，
ok” 习惯用法进行测试，
安全地，
确定该值是否为字符串：str
ok := value.
(string) if ok { fmt.Printf("字符串值为：%q\n",
str) } else { fmt.Printf("该值不是字符串\n") } 如果类型断言失败，
str 仍然存在，并且类型为字符串，
但它将具有零值，
一个空字符串。
为了说明这个能力，
这是一个 if - else 语句，等价于打开本节的类型开关。
如果 str,
ok := value.
(字符串);
ok { return str } else if str,
ok := value。
(字符串器);
ok { return str.String() } 通用性 如果一个类型仅用于实现一个接口，并且除了该接口之外永远不会有导出的方法，
则无需导出类型本身。
仅导出接口可以清楚地表明该值除了接口中描述的行为之外，没有其他有趣的行为了。
这也避免了在通用方法的每个实例上重复文档的需要。
在这种情况下，
构造函数应该返回一个接口值，而不是实现类型。
例如，
在哈希库中，crc32.NewIEEE 和 adler32.New 都返回接口类型 hash.Hash32。
在 Go 程序中用 CRC-32 算法代替 Adler-32 算法只需要更改构造函数调用；
代码的其余部分不受算法更改的影响。
类似的方法允许将各种加密包中的流密码算法与它们链接在一起的分组密码分离。
crypto/cipher 包中的 Block 接口指定了分组密码的行为，
它提供了对单个数据块的加密。
然后，
类似于 bufio 包，
实现此接口的 cipher 包可用于构造流密码，
由 Stream 接口表示，
在不了解块加密的细节的情况下。
crypto/cipher 接口如下所示： type Block interface { BlockSize() int Encrypt(dst,
src []byte) Decrypt(dst,
src []byte) } type Stream interface { XORKeyStream(dst,
src []byte) } 以下是计数器模式 (CTR) 流的定义，
它将分组密码转换为流密码；
请注意，分组密码的详细信息已被抽象出来：// NewCTR 返回一个 Stream，它使用给定的 Block 在计数器模式下加密/解密。
iv 的长度必须与 Block 的块大小相同。
func NewCTR(block Block,
iv []byte) Stream NewCTR 不仅适用于一种特定的加密算法和数据源，而且适用于 Block 接口和任何 Stream 的任何实现。
因为它们返回接口值，
用其他加密模式替换 CTR 加密是一个局部更改。
构造函数调用必须进行编辑，
但由于周围的代码必须仅将结果视为 Stream，
它不会注意到差异。
接口和方法 由于几乎任何东西都可以附加方法，
几乎任何东西都可以满足一个接口。
一个说明性的例子是在 http 包中，
它定义了 Handler 接口。
任何实现了 Handler 接口的对象都可以处理 HTTP 请求。
type Handler interface { ServeHTTP(ResponseWriter,
*Request) } ResponseWriter 本身就是一个接口，它提供了访问将响应返回给客户端所需的方法。
这些方法包括标准的 Write 方法，
因此，http.ResponseWriter 可以在任何可以使用 io.Writer 的地方使用。
Request 是一个结构体，包含来自客户端的请求的已解析表示。
为了简洁起见，
让我们忽略 POST 请求，并假设 HTTP 请求始终是 GET 请求；
这种简化不会影响处理程序的设置方式。
这是一个处理程序的一个简单实现，用于计算页面被访问的次数。
// 简单的计数器服务器。
type Counter struct { n int } func (ctr *Counter) ServeHTTP(w http.ResponseWriter,
req *http.Request) { ctr.
n++ fmt.Fprintf(w,
"counter = %d\n",
ctr.
n) } (与我们的主题保持一致，
请注意 Fprintf 如何打印到 http.ResponseWriter。
) 在真正的服务器中，
访问 ctr。
n 需要防止并发访问。
有关建议，请参阅 sync 和 atomic 包。
作为参考，
这是如何将这样的服务器附加到 URL 树上的一个节点。
import "net/http" ...
ctr := new(Counter) http.Handle("/counter",
ctr) 但为什么要将 Counter 设置为结构体？
只需要一个整数即可。
（接收器需要是指针，以便调用者可以看到增量。）
) // 更简单的计数器服务器。
type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter,
req *http.Request) { *ctr++ fmt.Fprintf(w,
"counter = %d\n",
*ctr) } 如果你的程序有一些内部状态需要被通知页面已被访问，该怎么办？
将通道绑定到网页。
// 一个在每次访问时发送通知的通道。
// (可能需要缓冲通道。
) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter,
req *http.Request) { ch <- req fmt.Fprint(w,
“已发送通知”）} 最后，
假设我们想在 /args 上展示调用服务器二进制文件时使用的参数。
编写一个函数来打印这些参数很容易。
func ArgServer() { fmt.Println(os.Args) } 我们如何将其转换为 HTTP 服务器？
我们可以将 ArgServer 作为某种类型的方法，而忽略其值，
但有一种更简洁的方法。
因为我们可以为除指针和接口之外的任何类型定义方法，
我们可以为一个函数编写一个方法。
http 包包含以下代码： // HandlerFunc 类型是一个适配器，允许将 // 普通函数用作 HTTP 处理程序。
如果 f 是一个具有适当签名的函数 //
HandlerFunc(f) 是一个 // 调用 f 的 Handler 对象。
type HandlerFunc func(ResponseWriter,
*Request) // ServeHTTP 调用 f(w,
req)。
func (f HandlerFunc) ServeHTTP(w ResponseWriter,
req *Request) { f(w,
req) } HandlerFunc 是一种带有方法的类型，
ServeHTTP ，
因此该类型的值可以处理 HTTP 请求。
请看该方法的实现：接收者是一个函数，
f ,
以及方法调用 f .
这可能看起来很奇怪，但它与以下情况并没有太大区别：
说，
接收器是一个通道，并且该方法在该通道上发送数据。
要将 ArgServer 转换为 HTTP 服务器，
我们首先修改它，使其具有正确的签名。
// 参数服务器。
func ArgServer(w http.ResponseWriter,
req *http.Request) { fmt.Fprintln(w,
os.Args) } ArgServer 现在具有与 HandlerFunc 相同的签名，
因此可以将其转换为该类型以访问其方法，
就像我们将 Sequence 转换为 IntSlice 以访问 IntSlice.Sort 一样。
设置它的代码很简单：http.Handle("/args",
http.HandlerFunc(ArgServer)) 当有人访问页面 /args 时，
安装在该页面的处理程序具有值 ArgServer 和类型 HandlerFunc。
HTTP 服务器将调用该类型的 ServeHTTP 方法，
并以 ArgServer 作为接收者，
这反过来将调用 ArgServer（通过 HandlerFunc.ServeHTTP 内部的调用 f(w,
req)）。
然后将显示参数。
在本节中，我们从一个结构体创建了一个 HTTP 服务器，
一个整数，
一个通道，
还有一个函数，
这都是因为接口只是方法的集合，
可以为（几乎）任何类型定义。
空白标识符 我们已经提到过几次空白标识符，
在 for range 循环和 map 的上下文中。
空白标识符可以被赋值或声明为任何类型的任何值，
并且该值会被无害地丢弃。
这有点像写入 Unix 的 /dev/null 文件：它表示一个只写的占位值，用于在需要变量但实际值无关紧要的情况下使用。
除了我们已经看到的用途之外，它还有其他用途。
空白标识符在多重赋值中的使用在 for range 循环中使用空白标识符是一种特殊情况：多重赋值。
如果赋值需要在左侧使用多个值，
但其中一个值不会被程序使用，
则赋值左侧的空白标识符可以避免创建虚拟变量，并清楚地表明该值将被丢弃。
例如，
当调用一个返回一个值和一个错误的函数时，
但只有错误是重要的，
使用空白标识符来丢弃不相关的值。
如果 _,
err := os.Stat(path);
os.IsNotExist(err) { fmt.Printf("%s 不存在\n",
path) } 有时你会看到一些代码为了忽略错误而丢弃错误值;
这是一种非常糟糕的做法。
始终检查错误返回值；
提供它们是有原因的。
// 不好！
如果路径不存在，此代码将会崩溃。
fi，
_ := os.Stat(path) 如果 fi.IsDir() { fmt.Printf("%s 是一个目录\n",
path) } 未使用的导入和变量。导入一个包或声明一个变量而不使用它是错误的。
未使用的导入会使程序膨胀并减慢编译速度，
而一个被初始化但未使用的变量至少是一种浪费的计算，并且可能表明存在更大的错误。
当程序处于积极开发阶段时，
然而，
经常会出现未使用的导入和变量，仅仅为了让编译继续而删除它们可能会很烦人，
结果之后又需要它们。
空白标识符提供了一种解决方法。
这个写了一半的程序有两个未使用的导入（fmt 和 io）和一个未使用的变量（fd），
所以它不会编译，
但如果能看看目前为止的代码是否正确就太好了。
package main import ( "fmt" "io" "log" "os" ) func main() { fd,
err := os.Open("test.go") 如果 err !
= nil { log.Fatal(err) } // TODO: 使用 fd。
} 为了消除关于未使用导入的抱怨，
使用空白标识符来引用导入包中的符号。
类似地，
将未使用的变量 fd 赋值给空白标识符将消除未使用的变量错误。
这个版本的程序可以编译。
package main import ( "fmt" "io" "log" "os" ) var _ = fmt.Printf // 用于调试；
完成后删除。
var _ io.Reader // 用于调试；
完成后删除。
func main() { fd,
err := os.Open("test.go") if err !
= nil { log.Fatal(err) } // TODO: 使用 fd。
_ = fd } 按照惯例，
为了消除导入错误，全局声明应该紧跟在导入语句之后，并加上注释，
这样既便于查找，又能提醒稍后进行清理。
导入以产生副作用。像前面示例中 fmt 或 io 这样未使用的导入最终应该被使用或删除：空白赋值将代码标识为正在进行的工作。
但有时仅为了它的副作用而导入一个包是很有用的，
而不进行任何显式使用。
例如，
在其 init 函数中，
net/http/pprof 包注册了提供调试信息的 HTTP 处理程序。
它有一个导出的 API，
但大多数客户端只需要处理程序注册，并通过网页访问数据。
要仅为了其副作用而导入包，
将包重命名为空标识符：import _ "net/http/pprof" 这种导入形式清楚地表明该包是为了其副作用而被导入的，
因为在该文件中，该包没有其他可能的用途，
它没有名字。
（如果它这样做，
并且我们没有使用那个名字，
编译器会拒绝该程序。
) 接口检查 正如我们在上面关于接口的讨论中看到的，
一个类型不需要显式声明它实现了某个接口。
相反，
一个类型只要实现了接口的方法，就实现了该接口。
在实践中，
大多数接口转换是静态的，因此在编译时进行检查。
例如，
将 *os.File 传递给需要 io.Reader 的函数将无法编译，除非 *os.File 实现了 io.Reader 接口。
有些接口检查发生在运行时，
虽然。
其中一个例子是在 encoding/json 包中，
它定义了一个 Marshaler 接口。
当 JSON 编码器接收到一个实现了该接口的值时，
编码器会调用该值的 marshaling 方法将其转换为 JSON，而不是执行标准转换。
编码器在运行时通过类型断言来检查此属性，例如：m,
ok := val。
(json.Marshaler) 如果只需要询问一个类型是否实现了接口，
而不实际使用接口本身，
也许是作为错误检查的一部分，
使用空白标识符来忽略类型断言的值：if _,
ok := val.
(json.Marshaler);
ok { fmt.Printf("类型为 %T 的值 %v 实现了 json.Marshaler\n", val, val) } 出现这种情况的一个原因是，需要在实现类型的包中保证它实际上满足接口。
val,
val) } 出现这种情况的一个原因是，需要在实现类型的包中保证它实际上满足接口。
如果一个类型——例如，
json.RawMessage ——需要自定义的 JSON 表示，
它应该实现 json.Marshaler，
但是没有静态转换会导致编译器自动验证这一点。
如果类型无意中未能满足接口，
JSON 编码器仍然可以工作，
但不会使用自定义实现。
为了保证实现的正确性，
在包中使用空白标识符的全局声明：var _ json.Marshaler = (*RawMessage)(nil)。在此声明中，
涉及将 *RawMessage 转换为 Marshaler 的赋值需要 *RawMessage 实现 Marshaler，
并且该属性将在编译时进行检查。
如果 json.Marshaler 接口发生更改，
这个包将无法再编译，我们会注意到它需要更新。
在这种结构中出现空白标识符表明该声明仅用于类型检查，
而不是创建变量。
不要为每个满足接口的类型都这样做，
虽然。
按照惯例，
只有当代码中没有静态转换时，才会使用此类声明，
这是一种罕见的情况。
嵌入 Go 不提供典型的，
类型驱动的子类化概念，
但它确实有能力通过在结构体或接口中嵌入类型来“借用”实现的片段。
接口嵌入非常简单。
我们之前提到过 io.Reader 和 io.Writer 接口；
这是它们的定义。
type Reader interface { Read(p []byte) (n int,
err error) } type Writer interface { Write(p []byte) (n int,
err error) } io 包还导出了几个其他接口，用于指定可以实现多个此类方法的对象。
例如，
这里有 io.ReadWriter，
一个包含 Read 和 Write 的接口。
我们可以通过显式列出这两种方法来指定 io.ReadWriter，
但嵌入这两个接口来形成新的接口更容易，也更能唤起记忆，
像这样：// ReadWriter 是组合了 Reader 和 Writer 接口的接口。
type ReadWriter interface { Reader Writer } 这句话的意思很明显：ReadWriter 可以做 Reader 能做的和 Writer 能做的；
它是嵌入式接口的联合。
只有接口可以嵌入到接口中。
同样的基本思想也适用于结构体，
但具有更深远的影响。
bufio 包有两个结构体类型，
bufio.Reader 和 bufio.Writer ，
当然，它们中的每一个都实现了包 io 中的类似接口。
并且 bufio 也实现了一个带缓冲的 reader/writer，
它通过将 reader 和 writer 组合成一个结构体来实现这一点，方法是使用嵌入：它在结构体中列出类型，但不给它们字段名。
// ReadWriter 存储指向 Reader 和 Writer 的指针。
// 它实现了 io.ReadWriter 接口。
type ReadWriter struct { *Reader // *bufio.Reader *Writer // *bufio.Writer } 嵌入的元素是指向结构的指针，当然必须先初始化为指向有效的结构，然后才能使用它们。
ReadWriter 结构可以写成 type ReadWriter struct { reader *Reader writer *Writer }，但是为了提升字段的方法并满足 io 接口，
我们还需要提供转发方法，
像这样：func (rw *ReadWriter) Read(p []byte) (n int,
err error) { return rw.reader.Read(p) } 通过直接嵌入结构体，
我们避免了这种簿记工作。
嵌入类型的方法是免费提供的，
这意味着 bufio.ReadWriter 不仅具有 bufio.Reader 和 bufio.Writer 的方法，
它还满足所有三个接口：io.Reader，
io.Writer，
和 io.ReadWriter。
嵌入与子类化在一个重要的方面有所不同。
当我们嵌入一个类型时，
该类型的方法会成为外部类型的方法，
但当它们被调用时，该方法的接收者是内部类型，
不是外面的那个。
在我们的例子中，
当调用 bufio.ReadWriter 的 Read 方法时，
它与上面写出的转发方法具有完全相同的效果；
接收器是 ReadWriter 的 reader 字段，
而不是 ReadWriter 本身。
嵌入也可以是一种简单的便利。
此示例显示了一个嵌入字段以及一个常规字段，
命名字段。
type Job struct { Command string *log.Logger } Job 类型现在具有 Print 、
Printf ,
Println 以及 *log.Logger 的其他方法。
当然，我们可以给 Logger 一个字段名，
当然，
但没有必要这样做。
现在，
一旦初始化，
我们可以记录到 Job 中：job.Println("starting now...
") Logger 是 Job 结构体的常规字段，"
因此我们可以像往常一样在 Job 的构造函数中初始化它，
像这样，
func NewJob(command string,
logger *log.Logger) *Job { return &Job{command,
logger *log.Logger) *Job { 返回 &Job{command,
logger} } or with a composite literal,
logger} } 或者使用复合字面量，
"工作：",
log.Ldate)} 如果我们需要直接引用一个嵌入字段，
字段的类型名称，
忽略包限定符，
用作字段名称，
就像在我们的 ReadWriter 结构体的 Read 方法中所做的那样。
在这里，
如果我们需要访问 Job 变量 job 的 *log.Logger，
我们会写 job.Logger 。
如果我们想要改进 Logger 的方法，这将非常有用。
func (job *Job) Printf(format string,
args ...
interface{}) { job.Logger.Printf("%q: %s",
job.Command,
fmt.Sprintf(format,
args...
)) } 嵌入类型引入了名称冲突的问题，但解决这些冲突的规则很简单。
首先，
字段或方法 X 会隐藏类型中更深层嵌套部分中的任何其他项 X。
如果 log.Logger 包含一个名为 Command 的字段或方法，
Job 的 Command 字段将覆盖它。
其次，
如果相同的名称出现在相同的嵌套级别，
这通常是一个错误；
如果 Job 结构体包含另一个名为 Logger 的字段或方法，则嵌入 log.Logger 将是错误的。
然而，
如果重复的名称在类型定义之外的程序中从未被提及，
没问题。
这种限定在一定程度上防止了对从外部嵌入的类型所做的更改；
如果添加的字段与另一个子类型中的另一个字段冲突，但这两个字段都从未使用过，则没有问题。
并发通过通信共享。并发编程是一个很大的主题，这里只介绍一些 Go 特有的亮点。
在许多环境中，并发编程由于需要实现对共享变量的正确访问而变得困难。
Go 提倡一种不同的方法，其中共享值在通道上传递，并且，
事实上，
永远不会被单独的执行线程主动共享。
任何给定时间只有一个 goroutine 可以访问该值。
数据竞争不会发生，
这是设计使然。
为了鼓励这种思维方式，我们将其简化为一句口号：不要通过共享内存来通信；
而是，
通过通信共享内存。
这种方法可能会走得太远。
引用计数最好通过在整数变量周围放置互斥锁来完成，
例如。
但作为一种高级方法，
使用通道来控制访问可以更容易地编写清晰的、
正确的程序。
考虑这种模型的一种方法是考虑在单个 CPU 上运行的典型单线程程序。
它不需要同步原语。
现在运行另一个这样的实例；
它也不需要同步。
现在让这两个进行通信；
如果通信是同步器，
仍然不需要其他同步。
Unix 管道，
例如，
完全符合此模型。
虽然 Go 的并发处理方法源于 Hoare 的通信顺序进程 (CSP)，
但它也可以被看作是 Unix 管道的一种类型安全的泛化。
Goroutines 它们被称为 goroutines 是因为现有的术语——线程，
协程，
进程，
等等——传达了不准确的含义。
一个 goroutine 有一个简单的模型：它是一个与同一地址空间中的其他 goroutine 并发执行的函数。
它很轻量，
成本仅仅略高于堆栈空间的分配。
并且堆栈开始时很小，
所以它们很便宜，
并且通过根据需要分配（和释放）堆存储来增长。
Goroutine 被多路复用到多个 OS 线程上，因此如果一个线程阻塞，
例如在等待 I/O 时，
其他人继续运行。
他们的设计隐藏了线程创建和管理的许多复杂性。
在函数或方法调用前加上 go 关键字，以在新的 goroutine 中运行该调用。
当调用完成时，
goroutine 退出，
静静地。
（效果类似于 Unix shell 中使用 & 符号在后台运行命令。）
) go list.Sort() // 并发运行 list.Sort；
不要等待它。
在 goroutine 调用中，函数字面量可能很方便。
func Announce(message string,
delay time.Duration) { go func() { time.Sleep(delay) fmt.Println(message) }() // 注意括号 - 必须调用该函数。
} 在 Go 中，
函数字面量是闭包：该实现确保函数引用的变量在其处于活动状态时仍然存在。
这些例子不太实用，因为这些函数无法发出完成信号。
为此，
我们需要通道。
像映射一样，通道
通道使用 make 分配，
并且结果值充当对底层数据结构的引用。
如果提供了可选的整数参数，
它设置通道的缓冲区大小。
默认值为零，
对于无缓冲或同步通道。
ci := make(chan int) // 整数的无缓冲通道 cj := make(chan int,
0) // 未缓冲的整数通道 cs := make(chan *os.File,
100) // 指向文件的指针的缓冲通道。未缓冲通道将通信（值的交换）与同步（保证两个计算（goroutine）处于已知状态）结合在一起。
使用通道有很多不错的习惯用法。
这是一个让我们开始的例子。
在上一节中，我们在后台启动了一个排序。
通过通道，启动 goroutine 可以等待排序完成。
c := make(chan int) // 分配一个通道。
// 在 goroutine 中启动排序；
完成时，
在通道上发出信号。
go func() { list.Sort() c <- 1 // 发送信号；
值无关紧要。
}() doSomethingForAWhile() <-c // 等待排序完成；丢弃发送的值。
丢弃发送的值。
接收者总是阻塞直到有数据可以接收。
如果通道是非缓冲的，
发送者会阻塞，直到接收者收到该值。
如果通道有一个缓冲区，
发送者仅在值被复制到缓冲区后才会阻塞；
如果缓冲区已满，
这意味着要等到某个接收者检索到一个值。
缓冲通道可以像信号量一样使用，
例如限制吞吐量。
在这个例子中，
传入的请求被传递给 handle，
它将一个值发送到通道中，
处理请求，
然后从通道接收一个值，使“信号量”为下一个消费者做好准备。
通道缓冲区的容量限制了对 process 的同时调用次数。
var sem = make(chan int,
MaxOutstanding) func handle(r *Request) { sem <- 1 // 等待活动队列耗尽。
process(r) // 可能需要很长时间。
<-sem // 完成；
允许运行下一个请求。
} func Serve(queue chan *Request) { for { req := <-queue go handle(req) // 不要等待 handle 完成。
} } 一旦执行了 MaxOutstanding 处理程序进程，
任何进一步的操作都会阻止尝试发送到已满的通道缓冲区中，
直到现有处理程序之一完成并从缓冲区接收。
这种设计有一个问题，
虽然：Serve 为每个传入的请求创建一个新的 goroutine，
尽管在任何时刻只能运行其中的 MaxOutstanding 个。
因此，
如果请求进入速度太快，程序可能会消耗无限的资源。
我们可以通过修改 Serve 来控制 goroutine 的创建来解决这个缺陷：func Serve(queue chan *Request) { for req := range queue { sem <- 1 go func() { process(req) <-sem }() } } (请注意，在 1.22 之前的 Go 版本中，此代码存在一个错误：循环变量在所有 goroutine 之间共享。
有关详细信息，请参阅 Go Wiki。
) 另一种很好地管理资源的方法是启动固定数量的处理 goroutine，全部从请求通道读取。
goroutine 的数量限制了对 process 的同时调用次数。
此 Serve 函数还接受一个通道，它将通过该通道被告知退出；
启动 goroutine 后，它会阻塞并从该通道接收数据。
func handle(queue chan *Request) { for r := range queue { process(r) } } func Serve(clientRequests chan *Request,
quit chan bool) { // 启动处理程序 for i := 0;
i < MaxOutstanding;
i++ { go handle(clientRequests) } <-quit // 等待被告知退出。
} 通道也是通道 Go 最重要的特性之一是通道是一等公民，可以像其他任何值一样被分配和传递。
此属性的一个常见用途是实现安全、
并行解复用。
在上一节的示例中，
“handle”是请求的理想化处理程序，但我们没有定义它正在处理的类型。
如果该类型包含一个用于回复的通道，
则每个客户端都可以提供自己的答案路径。
这是 Request 类型的示意性定义。
type Request struct { args []int f func([]int) int resultChan chan int } 客户端提供一个函数及其参数，
以及请求对象内部的一个通道，用于接收答案。
func sum(a []int) (s int) { for _,
v := range a { s += v } return } request := &Request{[]int{3,
总和，
make(chan int)} // Send request clientRequests <- request // Wait for response.
fmt.Printf("answer: %d\n",
<-request.resultChan) On the server side,
唯一改变的是处理函数。
func handle(queue chan *Request) { for req := range queue { req.resultChan <- req.
f(req.args) } } 显然，要使其更具真实感，还有很多工作要做，
但此代码是速率受限框架的基础，
并行的，
非阻塞 RPC 系统，
而且没有看到互斥锁。
并行化 这些想法的另一个应用是在多个 CPU 核心上并行计算。
如果计算可以分解为可以独立执行的单独部分，
它可以并行化，
使用通道来发出每个部分完成的信号。
假设我们需要对一个项目向量执行一个昂贵的操作，
并且每个项目上操作的值是独立的，
如本理想化示例所示。
type Vector []float64 // 将操作应用于 v[i]，
v[i+1] ...
直到 v[n-1]。
函数 (v Vector) DoSome(i,
n int,
u Vector,
c chan int) { for ;
i < n;
i++ { v[i] += u.Op(v[i]) } c <- 1 // 发出此部分已完成的信号 } 我们在一个循环中独立启动这些片段，
每个 CPU 一个。
它们可以以任何顺序完成，但这无关紧要；
我们只是通过在启动所有 goroutine 后耗尽通道来计算完成信号。
const numCPU = 4 // CPU 核心数 func (v Vector) DoAll(u Vector) { c := make(chan int,
numCPU) // 缓冲是可选的，但很合理。
for i := 0;
i < numCPU；
i++ { go v.DoSome(i*len(v)/numCPU,
(i+1)*len(v)/numCPU,
你，
c) } // 排空通道。
for i := 0;
i < numCPU;
i++ { // 等待一个任务完成 } // 全部完成。
} 与其为 numCPU 创建一个常量值，
我们可以询问运行时什么值是合适的。
函数 runtime.NumCPU 返回机器中硬件 CPU 核心的数量，
因此我们可以写成 var numCPU = runtime.NumCPU() 还有一个函数 runtime.GOMAXPROCS ，
它报告（或设置）用户指定的 Go 程序可以同时运行的核心数量。
它默认为 runtime.NumCPU 的值，但可以通过设置同名的 shell 环境变量或使用正数调用该函数来覆盖。
使用零调用它只是查询该值。
因此，如果我们想尊重用户的资源请求，
我们应该写 var numCPU = runtime.GOMAXPROCS(0) 务必不要混淆并发（将程序构建为独立执行的组件）和并行（为了在多个 CPU 上提高效率而并行执行计算）的概念。
虽然 Go 的并发特性可以使某些问题易于构建为并行计算，
Go 是一种并发语言，
而不是一种并行语言，
并且并非所有并行化问题都适合 Go 的模型。
关于区别的讨论，
请参阅此博客文章中引用的演讲。
泄漏的缓冲区 并发编程工具甚至可以使非并发的想法更容易表达。
这是一个从 RPC 包中抽象出来的例子。
客户端 goroutine 循环接收来自某些来源的数据，
也许是网络。
为了避免分配和释放缓冲区，
它保留了一个空闲列表，
并使用缓冲通道来表示它。
如果通道为空，
则会分配一个新的缓冲区。
消息缓冲区准备好后，
它通过 serverChan 发送到服务器。
var freeList = make(chan *Buffer,
100) var serverChan = make(chan *Buffer) func client() { for { var b *Buffer // 获取可用的缓冲区；
如果没有，则分配。
选择 { case b = <-freeList: // 得到一个；
没有什么可做的了。
default: // 没有空闲的，
所以分配一个新的。
b = new(Buffer) } load(b) // 从网络读取下一条消息。
serverChan <- b // 发送到服务器。
} } 服务器循环接收来自客户端的每条消息，
处理它，
并将缓冲区返回到空闲列表。
func server() { for { b := <-serverChan // 等待工作。
process(b) // 如果有空间，则重用缓冲区。
select { case freeList <- b: // 自由列表上的缓冲区；
没有什么可做的了。
default: // 自由列表已满，
继续前进。
}}} 客户端尝试从 freeList 中检索缓冲区；
如果没有可用的，
它会分配一个新的。
服务器发送到 freeList 会将 b 放回空闲列表，除非列表已满，
在这种情况下，缓冲区将被丢弃，并由垃圾回收器回收。
（当没有其他情况准备好时，select 语句中的默认子句会执行，
这意味着 select 永远不会阻塞。
) 此实现仅用几行代码构建了一个泄漏桶空闲列表，
依靠缓冲通道和垃圾收集器进行记账。
错误 库例程通常必须向调用者返回某种错误指示。
如前所述，
Go 的多值返回使得可以很容易地在返回正常值的同时返回详细的错误描述。
使用此功能提供详细的错误信息是一种好的风格。
例如，
正如我们将看到的，
os.Open 在失败时不仅仅返回一个 nil 指针，
它还会返回一个描述错误原因的 error 值。
按照惯例，
errors 的类型是 error ，
这是一个简单的内建接口。
type error interface { Error() string } 库的编写者可以自由地使用更丰富的模型来实现这个接口，
这样不仅可以看到错误，还可以提供一些上下文信息。
如前所述，
除了通常的 *os.File 返回值之外，
os.Open 也会返回一个错误值。
如果文件成功打开，
错误将为 nil ，
但当出现问题时，
它将保存一个 os.PathError：// PathError 记录一个错误以及导致该错误的操作和 // 文件路径。
type PathError struct { Op string // "open",
"unlink",
etc. Path string // 相关的文件。
Err error // 系统调用返回。
} func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() } PathError 的 Error 方法会生成一个类似这样的字符串：open /etc/passwx: no such file or directory 这样的错误，
其中包括有问题的文件名，
操作，
以及它触发的操作系统错误，
即使打印出来的结果远离了导致它的调用，它也很有用；
它比简单的“没有这样的文件或目录”更有信息量。
在可行的情况下，
错误字符串应该标识它们的来源，
例如，通过使用前缀来命名生成错误的操作或包。
例如，
在 image 包中，
由于未知格式导致的解码错误的字符串表示形式为“image: unknown format”。
关心精确错误详情的调用者可以使用类型开关或类型断言来查找特定错误并提取详情。
对于 PathError，这可能包括检查内部 Err 字段以查找可恢复的故障。
for try := 0;
try < 2;
尝试++ { 文件，
err = os.Create(filename) 如果 err == nil { return } 如果 e,
ok := err.
(*os.PathError);
好的 && e.Err == syscall.ENOSPC { deleteTempFiles() // 恢复一些空间。
继续 } return } 这里的第二个 if 语句是另一种类型断言。
如果它失败，
ok 将为 false，
并且 e 将为 nil。
如果成功，
ok 将为 true，
这意味着该错误是 *os.PathError 类型，
然后 e 也是如此，
我们可以检查它以获取有关该错误的更多信息。
Panic 向调用者报告错误的常用方法是返回一个错误作为额外的返回值。
规范的 Read 方法是一个众所周知的实例；
它返回一个字节计数和一个错误。
但是如果这个错误是无法恢复的呢？
有时程序根本无法继续。
为此，
有一个内置函数 panic，它实际上会创建一个运行时错误，导致程序停止（但请参阅下一节）。
该函数接受一个任意类型的参数（通常是一个字符串），并在程序终止时打印该参数。
这也是表明发生了不可能发生的事情的一种方式，
例如退出无限循环。
// 使用牛顿法实现立方根的一个简单示例。
func CubeRoot(x float64) float64 { z := x/3 // i 的任意初始值，从 i := 0 开始；
i < 1e6;
i++ { prevz := z z -= (z*z*z-x) / (3*z*z) 如果非常接近 (z,
prevz) { return z } } // 一百万次迭代后仍未收敛；
肯定有问题。
panic(fmt.Sprintf("CubeRoot(%g) 没有收敛",
x)) } 这只是一个例子，但真正的库函数应该避免 panic。
如果问题可以被掩盖或解决，
最好让程序继续运行，而不是关闭整个程序。
一个可能的反例是在初始化期间：如果库确实无法自行设置，
恐慌可能是合理的，
可以说是。
var user = os.Getenv("USER") func init() { if user == "" { panic("no value for $USER") } } Recover 当调用 panic 时，
包括对运行时错误的隐式调用，例如索引超出范围的切片或类型断言失败，
它立即停止当前函数的执行，并开始展开 goroutine 的堆栈，
并在执行过程中运行任何延迟函数。
如果展开到达 goroutine 堆栈的顶部，
程序会崩溃。
然而，
可以使用内置函数 recover 来重新获得对 goroutine 的控制并恢复正常执行。
调用 recover 会停止解构过程，并返回传递给 panic 的参数。
因为在解构过程中唯一运行的代码是在延迟函数内部，
recover 仅在延迟函数内部有用。
recover 的一个应用是在服务器中关闭一个失败的 goroutine，而不会杀死其他正在执行的 goroutine。
func server(workChan <-chan *Work) { for work := range workChan { go safelyDo(work) } } func safelyDo(work *Work) { defer func() { if err := recover();
错误！
= nil { log.Println("work failed:",
err) } }() do(work) } In this example,
if do(work) panics,
结果将被记录，并且 goroutine 将干净地退出，而不会干扰其他 goroutine。
在延迟闭包中无需执行任何其他操作；
调用 recover 可以完全处理这种情况。
因为 recover 总是返回 nil，除非直接从延迟函数调用，
延迟代码可以调用自身使用 panic 和 recover 而不会失败的库例程。
例如，
safelyDo 中的延迟函数可能会在调用 recover 之前调用日志记录函数，
并且该日志记录代码将不受 panic 状态的影响而运行。
有了我们的恢复模式，
do 函数（以及它调用的任何函数）可以通过调用 panic 来干净利落地摆脱任何糟糕的情况。
我们可以利用这个想法来简化复杂软件中的错误处理。
让我们看看一个理想化的 regexp 包，
它通过使用本地错误类型调用 panic 来报告解析错误。
这是 Error 的定义，
一个 error 方法，
以及 Compile 函数。
// Error 是解析错误的类型；
它满足 error 接口。
type Error string func (e Error) Error() string { return string(e) } // error 是 *Regexp 的一个方法，它通过 panic 报告解析错误，错误类型为 Error。
func (regexp *Regexp) error(err string) { panic(Error(err)) } // Compile 返回正则表达式的解析表示。
func Compile(str string) (regexp *Regexp,
err error) { regexp = new(Regexp) // 如果存在解析错误，doParse 将会 panic。
defer func() { if e := recover();
e ! Translation:
= nil { regexp = nil // 清除返回值。
err = e。
(错误) // 如果不是解析错误，将会重新 panic。
} }() 返回 regexp.doParse(str),
nil } 如果 doParse 发生 panic，
恢复块会将返回值设置为 nil——延迟函数可以修改命名返回值。
然后它会检查，
在赋值给 err 时，
通过断言它具有局部类型 Error ，表明问题是解析错误。
如果不是，
类型断言将会失败，
导致运行时错误，从而继续堆栈展开，就好像没有任何东西中断它一样。
此检查意味着如果发生意外情况，
例如索引超出范围，
即使我们使用 panic 和 recover 来处理解析错误，代码也会失败。
有了错误处理，
error 方法（因为它是一个绑定到类型的方法，
没问题，
甚至很自然，
因为它与内置的 error 类型同名）可以轻松报告解析错误，而无需担心手动展开解析堆栈：如果 pos == 0 { re.error("'*' 在表达式开头非法") } 虽然这种模式很有用，
它应该只在包内使用。
Parse 将其内部 panic 调用转换为错误值；
它不会向其客户端公开 panic。
这是一个值得遵循的好规则。
顺便说一句，
如果发生实际错误，此重新 panic 的习惯用法会更改 panic 值。
然而，
原始故障和新故障都将显示在崩溃报告中，
因此，问题的根本原因仍然可见。
因此，这种简单的重新 panic 方法通常就足够了——毕竟是崩溃——但如果你只想显示原始值，
你可以编写更多的代码来过滤掉意外的问题，并使用原始错误重新 panic。
这就留给读者作为练习了。
一个 web 服务器 让我们用一个完整的 Go 程序来结束，
一个网络服务器。
这个实际上是一种网络重服务器。
谷歌在 chart.apis.google.com 上提供一项服务，可自动将数据格式化为图表。
很难以交互方式使用，
虽然，
因为你需要将数据作为查询参数放入 URL 中。
这里的程序为一种数据形式提供了一个更友好的界面：给定一小段文本，
它调用图表服务器生成一个 QR 码，
这是一个编码文本的盒子矩阵。
那个图像可以用你手机的摄像头捕捉，并被解释为，
例如，
一个 URL，
让你免于在手机的小键盘上输入 URL。
这是完整的程序。
接下来是解释。
package main import ( "flag" "html/template" "log" "net/http" ) var addr = flag.String("addr",
"http 服务地址") // Q=17,
R=18 var templ = template.Must(template.New("qr").
Parse(templateStr)) func main() { flag.Parse() http.Handle("/",
http.HandlerFunc(QR)) err := http.ListenAndServe(*addr,
nil) if err !
= nil { log.Fatal("ListenAndServe:",
err) } } func QR(w http.ResponseWriter,
req *http.Request) { templ.Execute(w,
req.FormValue("s")) } const templateStr = ` <html> <head> <title>QR Link Generator</title> </head> <body> {{if .
}} <img src="http://chart.apis.google.com/chart?
chs=300x300&cht=qr&choe=UTF-8&chl={{.
}}" /> <br> {{.
}} <br> <br> {{end}} <form action="/" name=f method="GET"> <input maxLength=1024 size=70 name=s value="" title="Text to QR Encode"> <input type=submit value="Show QR" name=qr> </form> </body> </html> ` main 函数之前的部分应该很容易理解。
该 one 标志为我们的服务器设置了一个默认的 HTTP 端口。
模板变量 templ 是有趣的地方。
它构建了一个 HTML 模板，该模板将由服务器执行以显示页面；
稍后详细介绍。
主函数解析标志，并且，
使用我们上面讨论的机制，
将函数 QR 绑定到服务器的根路径。
然后调用 http.ListenAndServe 启动服务器；
它在服务器运行时会阻塞。
QR 只是接收请求，
其中包含表单数据，
并在名为 s 的表单值中的数据上执行模板。
html/template 模板包功能强大；
这个程序只是简单地介绍了它的功能。
本质上，
它通过替换从传递给 templ.Execute 的数据项派生的元素，动态地重写一段 HTML 文本，
在这种情况下，是表单值。
在模板文本 ( templateStr ) 中，
双花括号分隔的部分表示模板操作。
来自 {{if . 的片段
“}} 到 {{end}}” 仅在当前数据项的值（
称为 .）
(点),
为非空时执行。
也就是说，
当字符串为空时，
模板的这一部分将被抑制。
这两个代码片段{{.
}} 表示在网页上显示呈现给模板的数据（查询字符串）。
HTML 模板包自动提供适当的转义，因此文本可以安全显示。
模板字符串的其余部分只是页面加载时要显示的 HTML。
如果这个解释太快，
有关更详细的讨论，请参阅模板包的文档。
这就是您所拥有的：一个有用的 Web 服务器，只需几行代码加上一些数据驱动的 HTML 文本即可实现。
Go 足够强大，可以用几行代码完成很多事情。